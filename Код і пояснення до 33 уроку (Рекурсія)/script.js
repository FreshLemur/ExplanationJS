/* Рекурсія.
 Якщо дуже грубо вказати - рекурсія це функція, яка викликає себе. 
 */



// Це приклад рекурсії. Тобто, з циклу створилася рекурсія, котра робить теж саме.
// Так само важливо, щоб рекурсія мала кінець, щоб не зациклилася.

// Проте, першочергово це лише приклад, на прикладі циклу. Відповідно, використання рекурсії в такому випадку просто не має сенсу.

// function countDown (number) {
//   for (let i = number; i > 0; i--) {
//     console.log(i);
//   }
// }
// countDown(45)

// function countDownRecursively (number) {
//   if (number <= 0) {
//     console.log('Count down done');
//     return;
//   }
//   console.log(number)
//   countDownRecursively(number - 1);
// }
// countDownRecursively(45);

/* Опис, як працює функція countDownRecursively.
  
  Спочатку вона приймає число 45, умова if не працює. Працює 23 рядок, викликається знову функція, тепер 45-1. 
  Знову виклик функції, проте зараз число вже 44. Аналогічно, 44-1...43-1...42-1...1-1...
  Коли функція доходить до 1-1, це буде 0. Умова if спрацює і функція припинить свою дію.

*/



/*

Гіпотетичне завдання, яке може виникнути, при якому потрібно використовувати саме рекурсію, а не цикли.
Наприклад, маємо ось такий масив: const array = [1, 1, [2,2], [[3, [4, 5, [0]], 3], 2]].
Всередині цього масиву є інші масиви, а нам потрібно створити з ось такого один масив, який матиме вигляд:
[1, 1, 2, 2, 3, 4, 5, 0, 3, 2]

https://www.jsv9000.app/
На цьому сайті можна зручно побачити кроки.

*/

// const array = [1, 1, [2,2], [[3, [4, 5, [0]], 3], 2]];

// function concatArrRecursively(items) {
//   const flattened = []; // flat - пустий

//   items.forEach((item) => { 
//     if (Array.isArray(item)) { 
//     /* в глобального об'єкту Array є метод .isArray, який перевіряє, чи є наданий йому елемент масивом.
//     Тобто ця умова перевіряє, чи item є масивом, якщо є, то буде true */
//       flattened.push(...concatArrRecursively(item)); 
//       /* ... - Spread оператор. Він просто витягує елементи з масиву і закидує їх в новий масив. Наприклад:
//       const array1 = [1, 2, 3];
//       const array2 = [...array1, 4, 5];
//       console.log(array2); // [1, 2, 3, 4, 5]
//       Метод push закидає об'єкти в масив.
      
//       */
      
//     } else { // Якщо елемент не є масивом.
//       // console.log(item); Щоб побачити як все працюватиме.
//       flattened.push(item); // Якщо об'єкт не є масивом, тоді його просто закине в масив.
//     }
//   });
//   console.log(flattened)
//   return flattened;
// }
// concatArrRecursively(array);

/* Як працює функція concatArrRecursively.

Отже, вона пробігається по масиву array, в якому є інші масиви. Умова if (Array.isArray(item)) { перевіряє чи є елемент масивом. Якщо елемент є масивом,
тоді всередині умови викликається фукнція і за допомогою спред оператора (...) передаються елементи масиву в функцію. Таким чином проходиться по всьому масиву.


*/

const array1 = [1, 1, [2,2], [[3, [4, 5, [0]], 3], 2]];

// function awdhadk (items) {
//   const flattened = [];
//   items.forEach((item) => {
//     if (Array.isArray(item)) {
//       flattened.push(...awdhadk(item));
//     } else {
//       flattened.push(item);
//     }
//   })
//   console.log(flattened);
//   return flattened;
// }
// awdhadk(array1)

console.log(array1);

