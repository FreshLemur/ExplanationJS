/* try, catch, error, throw. 
Джерело: https://javascript.info/try-catch#finally-or-just-the-code
*/


// Синтаксис і загальна робота try/catch. 3-50 рядки.

// try {
//     alert('Start of try runs');  // (1) <--
//     // ...no errors here
//     alert('End of try runs');   // (2) <--
//   } catch (err) {
//     alert('Catch is ignored, because there are no errors'); // (3)
//     }
//     // Цей код працює таким чином: якщо в try є помилка, то код код зупинить своє виконання в блоці try і перейде до блоку catch. Якщо помилки немає,
//     // тоді код просто завершить своє виконання в блоці try.

// try {
//     alert('Start of try runs');  // (1) <--
//     lalala; // error, variable is not defined!
//     alert('End of try (never reached)');  // (2)
//   } catch (err) {
//     alert(`Error has occurred!`); // (3) <--
//   }
//   // В цьому випадку код має помилку, тому що lalala це і є помилка, undefined. Тому код не перейде до 18 рядка і перейде до блоку catch, 
//   // виводячи alert на 20 рядку.

// try catch працює лише для помилок виконання (винятками). Якщо буде синтаксично не правильним, то try catch просто не працюватиме, наприклад:
// try {
//     {{{{{{{{{{{{
//   } catch (err) {
//     alert("The engine can't understand this code, it's invalid");
//   }

// Якщо виняток виникає у "запланованому" коді, наприклад, у setTimeout, try...catch не перехопить його:
// try {
//     setTimeout(function() {
//       noSuchVariable; // script will die here \ скрипт помре тут.
//     }, 1000);
//   } catch (err) {
//     alert( "won't work" );
//   }

// Це тому, що сама функція виконується пізніше, коли рушій вже вийшов з конструкції try...catch.
// Щоб перехопити виключення всередині запланованої функції, try...catch має бути всередині цієї функції:
// setTimeout(function() {
//     try {
//       noSuchVariable; // try...catch handles the error!
//     } catch {
//       alert( "error is caught here!" );
//     }
//   }, 1000);



/* */

// /* Error object 
// Коли виникає помилка, JavaScript генерує об'єкт, що містить детальну інформацію про неї. 
// Потім цей об'єкт передається як аргумент для перехоплення:
// try {
//     ...
//    } catch (err) { // <-- the "error object", could use another word instead of err \ <-- "об'єкт помилки", можна було б використати інше слово замість err
//      // ...
//    }
// */

// try {
//     lalala; // error, variable is not defined! \ помилка, змінна не визначена!
//   } catch (err) {
//     alert(err.name); // ReferenceError \ Помилка посилання
//     alert(err.message); // lalala is not defined \ lalala не визначений
//     alert(err.stack); // ReferenceError: lalala is not defined at (...call stack) \ Помилка посилання: lalala не визначений в (...стеку викликів)

//     // Can also show an error as a whole \ Може також виводити помилку в цілому
//     // The error is converted to string as "name: message" \ Помилка конвертується в рядок у вигляді "name: message"
//     alert(err); // ReferenceError: lalala is not defined \ Помилка посилання: lalala не визначений
//   }



/* */

/* Optional “catch” binding \ Необов'язкова прив'язка "catch".
Якщо нам не потрібна детальна інформація про помилку, catch може її опустити:     
try {
  // ...
} catch { // <-- without (err)
  // ...
}*/



/* */

// /* Using “try…catch” \ Використання "спробуй...злови" 
// Давайте розглянемо реальний випадок використання try...catch.
// Як ми вже знаємо, JavaScript підтримує метод JSON.parse(str) для читання JSON-кодованих значень.
// Зазвичай він використовується для декодування даних, отриманих по мережі, з сервера або іншого джерела.
// Ми отримуємо їх і викликаємо JSON.parse ось так:     */

// // let json = '{"name":"John", "age": 30}'; // data from the server \ дані з серверу
// // let user = JSON.parse(json); // convert the text representation to JS object \ перетворення текстового представлення в JS-об'єкт
// // // now user is an object with properties from the string \ тепер користувач є об'єктом з властивостями з рядка
// // alert( user.name ); // John
// // alert( user.age );  // 30

// // Якщо json неправильно сформований, JSON.parse видає помилку, і скрипт "помирає".

// // Чи повинні ми задовольнятися цим? Звичайно, ні!
// // Таким чином, якщо з даними щось не так, відвідувач ніколи не дізнається про це (якщо тільки не відкриє консоль розробника). 
// // А люди дуже не люблять, коли щось "просто помирає" без жодного повідомлення про помилку.
// // Давайте використаємо try...catch для обробки помилки:let json = "{ bad json }";
// try {
//     let user = JSON.parse(json); // <-- when an error occurs... \ <-- при виникненні помилки...
//     alert(user.name); // doesn't work \ не працює
//   } catch (err) {
//     // ...the execution jumps here \ ...страта стрибає тут.
//     alert( "Our apologies, the data has errors, we'll try to request it one more time." ); 
//     // Приносимо свої вибачення, дані містять помилки, ми спробуємо запросити їх ще раз.
//     alert(err.name);
//     alert(err.message);

//     // Тут ми використовуємо блок catch тільки для того, щоб показати повідомлення, але ми можемо зробити набагато більше: 
//     // відправити новий мережевий запит, запропонувати відвідувачу альтернативу, відправити інформацію про помилку в лог-файл, ... . 
//     // Все набагато краще, ніж просто померти.
//   }



/* */

// /* Throwing our own errors \ Відкидаємо власні помилки:

// Що робити, якщо json синтаксично правильний, але не має необхідної властивості name?
// Наприклад, так:    */

// // let json = '{ "age": 30 }'; // incomplete data
// // try {
// //   let user = JSON.parse(json); // <-- no errors
// //   alert( user.name ); // no name!
// // } catch (err) {
// //   alert( "doesn't execute" );
// // }

// // Тут JSON.parse працює нормально, але відсутність імені є для нас помилкою.
// // Щоб уніфікувати обробку помилок, ми використаємо оператор throw.
// // Оператор "throw"
// // Оператор throw генерує помилку.
// // Синтаксис наступний:
// // throw <error object>

// // Технічно, ми можемо використовувати що завгодно як об'єкт помилки. Це може бути навіть примітив, наприклад, число або рядок, 
// // але краще використовувати об'єкти, бажано з властивостями імені та повідомлення (щоб залишатися сумісними з вбудованими помилками).
// // JavaScript має багато вбудованих конструкторів для стандартних помилок: Error, SyntaxError, ReferenceError, TypeError та інші.
// // Ми також можемо використовувати їх для створення об'єктів помилок.
// // Їх синтаксис наступний:

// // let error = new Error(message);
// // // or
// // let error = new SyntaxError(message);
// // let error = new ReferenceError(message);
// // // ...

// // Для вбудованих помилок (не для будь-яких об'єктів, а саме для помилок) властивість name - це саме ім'я конструктора. 
// // А повідомлення береться з аргументу. Наприклад:
// // let error = new Error("Things happen o_O");
// // alert(error.name); // Error
// // alert(error.message); // Things happen o_O

// // Подивимося, яку помилку видає JSON.parse:
// // try {
// //     JSON.parse("{ bad json o_O }");
// //   } catch (err) {
// //     alert(err.name); // SyntaxError
// //     alert(err.message); // Unexpected token b in JSON at position 2 \ Expected property name or '}' in JSON at position 2 (line 1 column 3)
// //   }
// // Як бачимо, це синтаксична помилка. SyntaxError.
// // А в нашому випадку відсутність імені є помилкою, оскільки користувачі повинні мати ім'я.
// // Тож давайте викинемо його:
// // let json = '{ "age": 30 }'; // incomplete data \ неповні дані
// // try {
// //   let user = JSON.parse(json); // <-- no errors \ немає помилок
// //   if (!user.name) {
// //     throw new SyntaxError("Incomplete data: no name"); // (*)
// //   }
// //   alert( user.name );
// // } catch (err) {
// //   alert( "JSON Error: " + err.message ); // JSON Error: Incomplete data: no name
// // }
// // У рядку (*) оператор throw генерує SyntaxError з заданим повідомленням, так само, як це зробив би сам JavaScript. 
// // Виконання try негайно зупиняється і потік управління переходить в catch.
// // Тепер catch став єдиним місцем для обробки всіх помилок: як для JSON.parse, так і для інших випадків.


// /* Rethrowing \ Перекидання Відкидання Перезавантаження*/ 

// // У наведеному вище прикладі ми використовуємо try...catch для обробки некоректних даних. 
// // Але чи можливо, що всередині блоку try {...} виникає інша непередбачувана помилка? Наприклад, помилка програмування (змінна не визначена) 
// // або щось інше, а не просто "некоректні дані". Наприклад:
// // let json = '{ "age": 30 }'; // incomplete data \ неповні дані
// // try {
// //   user = JSON.parse(json); // <-- forgot to put "let" before user \ <-- забули поставити "let" перед користувачем
// //   // ...
// // } catch (err) {
// //   alert("JSON Error: " + err); // JSON Error: ReferenceError: user is not defined
// //   // (no JSON Error actually) \ насправді немає помилки JSON
// // }
// // Звичайно, все можливо! Програмісти роблять помилки. Навіть в утилітах з відкритим вихідним кодом, 
// // кими користуються мільйони протягом десятиліть - раптом може бути виявлена помилка, яка призводить до жахливих зломів.
// // У нашому випадку, try...catch призначений для перехоплення помилок "некоректних даних". 
// // Але за своєю природою catch отримує всі помилки від try. Тут він отримує неочікувану помилку, але все одно показує те саме повідомлення 
// // "JSON Error". Це неправильно, а також ускладнює налагодження коду.

// // Щоб уникнути таких проблем, ми можемо застосувати техніку "перекидання". Правило просте:
// // Catch повинен обробляти тільки ті помилки, які йому відомі, і "перекидати" всі інші.
// // Більш детально техніку "перекидання" можна пояснити так:

// // Catch отримує всі помилки.
// // У блоці catch (err) {...} ми аналізуємо об'єкт помилки err.
// // Якщо ми не знаємо, як його обробити, ми просто перекидаємо err.
// // Зазвичай ми можемо перевірити тип помилки за допомогою оператора instanceof:
// // try {
// //     user = { /*...*/ };
// //   } catch (err) {
// //     if (err instanceof ReferenceError) {
// //       alert('ReferenceError'); // "ReferenceError" for accessing an undefined variable
// //     }
// //   }
// // Ми також можемо отримати назву класу помилки з властивості err.name. Її мають усі нативні помилки. Інший варіант - прочитати err.constructor.name.

// // У коді нижче ми використовуємо перекидання, щоб catch обробляв тільки SyntaxError:
// // let json = '{ "age": 30 }'; // incomplete data \ неповні дані
// // try {
// //   let user = JSON.parse(json);
// //   if (!user.name) {
// //     throw new SyntaxError("Incomplete data: no name");
// //   }
// //   blabla(); // unexpected error \ неочікувана помилка
// //   alert( user.name );
// // } catch (err) {
// //   if (err instanceof SyntaxError) {
// //     alert( "JSON Error: " + err.message ); // JSON Error: Incomplete data: no name.
// //   } else {
// //     throw err; // rethrow (*) \ перекидання
// //   }
// // }
// // Помилка, що виводить на рядок (*) зсередини блоку catch, "випадає" з try...catch і може бути або 
// // перехоплена зовнішньою конструкцією try...catch (якщо вона існує), або вбиває скрипт.

// // Таким чином, блок catch фактично обробляє тільки ті помилки, з якими він вміє працювати, і "пропускає" всі інші.
// // Приклад нижче демонструє, як такі помилки можуть бути відловлені ще одним рівнем try...catch:
// // function readData() {
// //     let json = '{ "age": 30 }';
// //     try {
// //       // ...
// //       blabla(); // error!
// //     } catch (err) {
// //       // ...
// //       if (!(err instanceof SyntaxError)) {
// //         throw err; // rethrow (don't know how to deal with it) // перекидання (не знаємо, як з цим боротися)
// //       }
// //     }
// //   }
// //   try {
// //     readData();
// //   } catch (err) {
// //     alert( "External catch got: " + err ); // caught it! \ Спіймав!
// //   }
// // // Тут readData вміє обробляти тільки SyntaxError, тоді як зовнішній try...catch вміє обробляти все.



/* */

// /* try…catch…finally \ спробувати... зловити... нарешті */
// // Зачекайте, це ще не все.
// // У конструкції try...catch може бути ще один пункт коду: finally.
// // Якщо воно є, то виконується у всіх випадках:
// // після try, якщо не було помилок,
// // після catch, якщо помилки були.
// // Розширений синтаксис виглядає так:
// // try {
// //     ... try to execute the code ... \ спробуємо виконати код
// //  } catch (err) {
// //     ... handle errors ... \ обробка помилок
// //  } finally {
// //     ... execute always ... \ виконується завжди
// //  }

// // Try running this code:
// // try {
// //     alert( 'try' );
// //     if (confirm('Make an error?')) BAD_CODE();
// //   } catch (err) {
// //     alert( 'catch' );
// //   } finally {
// //     alert( 'finally' );
// //   }
// // Код має два шляхи виконання:
// // Якщо ви відповідаєте "Так" на питання "Виникла помилка?", то виконується try -> catch -> finally.
// // Якщо ви відповідаєте "Ні", то try -> finally.

// // Речення finally часто використовується, коли ми починаємо щось робити і хочемо завершити це в будь-якому випадку результату.
// // Наприклад, ми хочемо виміряти час, за який функція чисел Fibonacci fib(n) виконується. 
// // Звичайно, ми можемо почати вимірювання до того, як вона почне працювати, і закінчити після. 
// // Але що, якщо під час виклику функції виникне помилка? Зокрема, реалізація функції fib(n) у коді нижче повертає помилку для від'ємних або нецілих чисел.
// // Речення finally - це чудове місце для завершення вимірювань, незважаючи ні на що.
// // Тут finally гарантує, що час буде виміряно правильно в обох ситуаціях - у випадку успішного виконання fib і у випадку помилки в ній:

// // let num = +prompt("Enter a positive integer number?", 35) // Введіть позитивне ціле число? 
// // Цей код використовує prompt для отримання від користувача цілого числа, і, якщо користувач введе значення, це буде збережено у змінній num. 
// // У разі відмови або введення нечислового значення у num залишиться значення 35
// // let diff, result; // змінні без присвоєних значень
// // function fib(n) {
// //   if (n < 0 || Math.trunc(n) != n) {
// //     throw new Error("Must not be negative, and also an integer."); // Не повинно бути від'ємним, а також цілим числом.
// //   }
// //   return n <= 1 ? n : fib(n - 1) + fib(n - 2);
// // }
// // let start = Date.now();
// // try {
// //   result = fib(num);
// // } catch (err) {
// //   result = 0;
// // } finally {
// //   diff = Date.now() - start;
// // }
// // alert(result || "error occurred");
// // alert( `execution took ${diff}ms` );
// /* Пояснення від GPT 
// 1. `let num = +prompt("Enter a positive integer number?", 35)`: Цей рядок використовує `prompt` для отримання від користувача цілого числа. 
// `+` перед `prompt` перетворює введене значення на число. Якщо користувач не введе жодного значення, використовується значення за замовчуванням, яке тут рівне 35.
// 2. `function fib(n) {...}`: Ця функція обчислює число Фібоначчі для заданого `n`. Функція використовує рекурсію для розрахунку чисел Фібоначчі. 
// Зокрема, вона викликає сама себе для `n - 1` та `n - 2`, аж поки `n` не стане менше або дорівнюватиме 1.
// 3. `if (n < 0 || Math.trunc(n) != n) {...}`: Цей рядок перевіряє, чи передане значення `n` є не від'ємним цілим числом. 
// `Math.trunc` відсікає десяткову частину числа, і якщо після цього значення не дорівнює `n`, викидається помилка.
// 4. `let start = Date.now();`: Ця команда створює змінну `start` і записує в неї час (в мілісекундах), коли ця команда була викликана. 
// Тобто, це використовується для визначення часу початку виконання коду.
// 5. `try {...} catch (err) {...} finally {...}`: Це конструкція для обробки помилок. Код у блоку `try` виконується, 
// і якщо виникає помилка, вона обробляється у блоку `catch`. Незалежно від того, чи сталася помилка чи ні, блок `finally` викликається. 
// У даному випадку, час виконання коду вимірюється, навіть якщо виникає помилка у функції `fib`.
// 6. `alert(result || "error occurred");`: Ця команда виводить результат обчислення числа Фібоначчі або повідомлення про помилку у випадку, якщо сталася помилка.
// 7. `alert( `execution took ${diff}ms` );`: Ця команда виводить повідомлення про те, скільки часу зайняло виконання коду, 
// використовуючи різницю між поточним часом і часом початку виконання коду.
// Отже, цей код вводить число від користувача, обчислює число Фібоначчі за допомогою рекурсивної функції, вимірює час виконання цього процесу, 
// і виводить результат та час виконання.*/
// // Ви можете перевірити, запустивши код, ввівши в інтерпретаторі 35 - він виконується нормально, нарешті, після спроби. 
// // А якщо ввести -1 - одразу виникне помилка, і виконання займе 0 мс. Обидва виміри зроблено коректно.
// // Іншими словами, функція може закінчуватися return або throw, це не має значення. В обох випадках виконується оператор finally.
// // Змінні є локальними всередині try...catch...finally
// // Зверніть увагу, що змінні result і diff у вищенаведеному коді оголошені перед try...catch.
// // Інакше, якщо б ми оголосили let в блоці try, то він був би видимий тільки всередині нього.

// // finally і return
// // Оператор finally працює для будь-якого виходу з try...catch. Це включає явне повернення.
// // У прикладі нижче є повернення в try. У цьому випадку finally виконується безпосередньо перед тим, як елемент управління повертається до зовнішнього коду.
// // function func() {
// //   try {
// //     return 1;
// //   } catch (err) {
// //     /* ... */
// //   } finally {
// //     alert( 'finally' );
// //   }
// // }
// // alert( func() ); // first works alert from finally, and then this one \ спочатку спрацьовує сповіщення від finally, а потім це

// // Також корисною є конструкція try...finally, без catch-клаузули. Ми застосовуємо її, коли не хочемо обробляти помилки 
// // тут (нехай вони самі вилітають), але хочемо бути впевненими, що розпочаті нами процеси будуть завершені.
// // function func() {
// //   // start doing something that needs completion (like measurements) \ почніть робити щось, що потребує завершення (наприклад, вимірювання)
// //   try {
// //     // ...
// //   } finally {
// //     // complete that thing even if all dies \ завершити цю справу, навіть якщо всі помруть.
// //   }
// // }
// // У вищенаведеному коді завжди випадає помилка всередині Try, тому що там немає підхоплення. 
// // Але Finally спрацьовує до того, як потік виконання покине функцію.



/* */

// Summury \ Підсумок

// Конструкція try...catch дозволяє обробляти помилки під час виконання. Вона буквально дозволяє "спробувати" 
// виконати код і "перехопити" помилки, що можуть виникнути в ньому.

// The syntax is:
// try {
//   // run this code
// } catch (err) {
//   // if an error happened, then jump here
//   // err is the error object
// } finally {
//   // do in any case after try/catch
// }

// Секції catch або finally може не бути, тому більш короткі конструкції try...catch та try...finally також є допустимими.
// Об'єкти помилок мають наступні властивості:
// message - повідомлення про помилку у вигляді, зрозумілому для людини.
// name - рядок з назвою помилки (ім'ям конструктора помилки).
// стек (нестандартний, але добре підтримується) - стек на момент створення помилки.
// Якщо об'єкт помилки не потрібен, його можна опустити, використовуючи catch { замість catch (err) {.
// Ми також можемо генерувати власні помилки за допомогою оператора throw. Технічно аргументом throw може бути
//  що завгодно, але зазвичай це об'єкт помилки, успадкований від вбудованого класу Error. Детальніше про розширення помилок у наступному розділі.
// Перекидання є дуже важливим шаблоном обробки помилок: блок catch зазвичай очікує і знає, як обробляти певний тип помилки, 
// тому він повинен перекидати помилки, яких він не знає.
// Навіть якщо у нас немає try...catch, більшість середовищ дозволяють налаштувати "глобальний" обробник помилок, щоб 
// перехоплювати помилки, які "випадають". У браузері це window.onerror.



/* */

// Task \ Завдання
// Finally чи тільки код?
// важливість: 5
// Порівняйте два фрагменти коду.

// // У першому використовується finally для виконання коду після try...catch:
// try {
//   // work work \ робота робота
// } catch (err) {
//   // handle errors \ обробка помилок
// } finally {
//   // cleanup the working space \ прибрати робочий простір
// }

// // У другому фрагменті прибирання відбувається одразу після спроби... упіймання:
// try {
//   // work work \ робота робота
// } catch (err) {
//   // handle errors \ обробка помилок
// }
// // cleanup the working space \ прибрати робочий простір

// Нам обов'язково потрібне очищення після роботи, незалежно від того, була помилка чи ні.
// Чи є тут перевага у використанні finally або обидва фрагменти коду рівноцінні? Якщо є, то наведіть приклад, коли це має значення.

/* Мої думки на час вирішення цього завдання, коли я лише просто описав це все, не читаючи коментарі чи рішення.
  Так, є перевага у використанні finally. Навіть, якщо подивитися з точки зору області видимості, то буде коректніше і правильніше
  використовувати саме finally, тому що він матиме доступ до внутрішньої області видимості, а також це буде корисно для структури і архітектури коду.
  Та й finally буде спрацьовувати завжди, в не залежності чи спрацювало try або catch чи ні.
*/

/* Тут опис відповіді на завдання:

Різниця стає очевидною, коли ми дивимося на код всередині функції.
Поведінка змінюється, якщо з try...catch є "вихід".
Наприклад, коли всередині try...catch є return. Оператор finally працює при будь-якому виході з try...catch, 
навіть через оператор return: одразу після завершення try...catch, але до того, як викликаючий код отримає керування.
*/
// function f() {
//   try {
//     alert('start');
//     return "result";
//   } catch (err) {
//     /// ...
//   } finally {
//     alert('cleanup!');
//   }
// }
// f(); // cleanup!

// ...Або коли є throw, як тут:
// function f() {
//   try {
//     alert('start');
//     throw new Error("an error");
//   } catch (err) {
//     // ...
//     if("can't handle the error") {
//       throw err;
//     }
//   } finally {
//     alert('cleanup!')
//   }
// }
// f(); // cleanup!

// Це, нарешті, гарантує очищення тут. Якби ми просто додали код в кінець f, він би не працював у цих ситуаціях.
