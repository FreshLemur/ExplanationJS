/* Event Loop / Цикл подій. Потрібен, щоб обходити однопоточність JS.

  Простими словами: в якій порядковості виконується код JS.
  JS - однопоточна мова програмування, може виконувати лише 1 дію в даний момент. 



  Посилання на сайт з загальним поясненням Event Loop.
  https://dev.to/papidiagne30/javascript-event-loop-for-dummies-1bdi
  */



// В цьому прикладі все йде по порядку.
// function showNumber(number) {
// console.log(number); // 3
// }

// console.log(1); //  1
// console.log(2); // 2

// showNumber(3); // 3

// console.log(4); // 4

// for (let i = 5; i < 9; i++) { // 5, 6, 7, 8
//   console.log(i);
// }

// showNumber(9); // 9

// console.log(10); // 10



/* В цьому прикладі спочатку виведеться two(2), потім console.log(4);, потім Promise.resolve(5).then(four);, тому що він не має ніякої затримки
Потім setTimeout(one, 0);, тому що тут вже є затримка, але лише 0мс, потім setTimeout(three, 1000);, тому що тут затримка в цілу секунду. 
Якщо закинути цей код на https://www.jsv9000.app/, то можна побачити як він працює.
Опишу його.
JS бачить setTimeout(one, 0); і закидує його в Task Queue (Callback Queue), тому що це асинхронний код, від API.
Потім йде two(). Це синхронний код, він потрапляє до Call Stack і просто виконується console.log.
Потім йде setTimeout(three, 1000), він також є асинхронним від API, тому Call Stack закидує його до Task Queue.
Потім знову йде синхронний код, console.log(4), він просто виводиться.
Потім йде Promise.resolve(5).then(four) і потрапляє в окрему чергу, для промісів, яка називається Microtask Queue.
Тепер Call Stack пустий і спочатку JS бере перше, що було закинуто до Microtask Queue, а це проміс. Виконується дія промісу, він зникає.
Після цього, нарешті, черга йде до Task Queue, виконується спочатку setTimeout(one, 0), а після нього setTimeout(three, 1000).
Це все можна в ілюстраціях побачити на сайті.
*/

// function one() {
//   console.log(1);
// }

// function two() {
//   console.log(2);
// }

// function three() {
//   console.log(3);
// }

// function four(number) {
//   console.log(number);
// }

// setTimeout(one, 0); // 4

// two(); // 1

// setTimeout(three, 1000); // 5

// console.log(4); // 2

// Promise.resolve(5).then(four); // 3



/* JS Engine / JS Двигун.
  Його мета дуже проста. Виконати JS код і трансформувати його в машинний код, тобто бінарник (0,1), який може читати комп'ютер.
  Водночас він може робити лише одну дію, це можна побачити в наступному коді, закинувший його на сайт https://www.jsv9000.app/
*/

// function one () {
//   console.log(1)
// }

// function two () {
//   one()
//   console.log(2)
// }

// function three () {
//   two()
//   console.log(3)
// }

// function four (number) {
//   three()
//   console.log(4)
// }

// four();

/* Спочатку викличеться функція four();, потім вона викличе функцію three (), потім вона викличе функцію two (), потім вона викличе функцію one (). Виконала 4 дії.
  Функції one(), two(), three(), four() є в Call Stack
  Тепер, коли JS доходить до функції one(), він починає виводити консольки.
  Спочатку виведе в консоль 1 і функція one () пропаде з Call Stack. Потім виведе в консоль 2 і функція two() пропаде з Call Stack.
  Потім виведе в косноль 3 і функція three() пропаде з Call Stack, в кінці виведе в консоль 4 і фукнція four видалиться з CallStack.

  Call Stack - це структура даних, яка використовується в програмуванні для відстеження викликів функцій у вашій програмі. 
  Коли ви викликаєте функцію, вона додається до верху стеку, і коли функція завершує виконання, вона видаляється з верху стеку.
  Основний принцип роботи Call Stack можна розглядати так:
  Виклик функції: Коли ви викликаєте функцію, її контекст (локальні змінні, параметри, адреса повернення) додається до верху стеку.
  Виконання коду: Виконується код функції, яку ви викликали, і може виникнути інші виклики функцій усередині неї. Кожен новий виклик додається до верху стеку.
  Повернення з функції: Коли функція завершує виконання, її контекст видаляється з верху стеку, і виконання продовжується з того місця, звідки була викликана ця функція.
  Цей процес триває, доки стек не стане порожнім. Якщо стек стає занадто великим (наприклад, через рекурсивні виклики без закінчення), може виникнути переповнення стеку.
  Call Stack є важливою частиною відстеження виконання програми та роботи зі стековими фреймами функцій.
*/



/* Продовження прояснення про Call Stack

Коли в Call Stack попадає якась функція, яка не є складовою JS, а є складовою Web API браузера, наприклад:
функція timeOut (setTimeout); Ajax(fetch); DOM; Всі WEBApis: https://developer.mozilla.org/en-US/docs/Web/API,
То тоді вона переноситься в окрему чергу очікування, тобто в асинхронний код.
Після цього, з Web APIs черги воно потрапляє в Callback Queue і цей асинхронний код не виконається доти, доки повністю не очиститься Call Stack,
відповідно доти, доки не виконається повністю весь синхронний код.
Event Loop(цикл подій) потійно перевіряє чи не очистився Call Stack. Коли він бачить, що Call Stack очистився повністю і всі його синхронні дії
виконалися, то до Call Stack додаються асинхронні функції і лише тоді вже виконуються.

Посилання на сайт з загальним поясненням Event Loop.
https://dev.to/papidiagne30/javascript-event-loop-for-dummies-1bdi

Посилання на сайт з прикладом синхронного коду:
https://jsfiddle.net/81wo6tdL/3/
// Сайту потрібно зробити fetch запит. Цей приклад має абсолютно синхронний код. Поки виконується асинхронний код, користувач не може взаємодіями з сайтом.

Посилання на сайт з прикладом асинхронного коду:
https://jsfiddle.net/tpsfqh4x/
В цьому прикладі відбувається асинхронний код, разом з синхронним. Поки відбувається асинхронний код, користувач може взаємодіяти із зайтом.

*/
